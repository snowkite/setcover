#ifndef SETCOVER_H
#define	SETCOVER_H

/**
 * Решения задачи нахождения среди множества к бинарных слов длины n 
 * минимального подмножества образуещего единичного покрытия без наложения.
 * покрытия 
 * Битовые последовательности(двоичные слова) представлены в виде чисел. 
 * 000 - 0
 * 001 - 1
 * 010 - 2
 * 011 - 3
 * и т. д.
 * Тип данных задаётся через template 
 * Есть возможность задать свой тип, и хранить массивами...
 **/

/**
 * full_iterator - класс для циклов.
 * Производит полный перебор всех возможных вариантов
 * для заданного количества битовых наборов и их длины.
 * newfile
 * Также может использоваться для переборов диапазонов вариантов.
 **/
template <class T>
class full_iterator {
private:

    /**
     * Основной массив, в котором хранятся последовательности
     **/
    T* array;

    /**
     * Кл-во слов
     **/
    int k;   


    /**
     * Максимально возможное число.
     * 1  - 1
     * 3  - 11
     * 7  - 111
     * 15 - 1111
     * и т. д.
     **/
    T m;

    /**
     * @param n - количество бит
     * @return T число для n 
     * старшие биты которого состоят из единиц.
     **/
    T get_max_bnumber(int n);

public:

    /**
     * @param a - основной массив
     * @param n - длина слова
     * @param k - количество слов
     **/
    full_iterator(T *a, int n, int kolich);

    /**
     * Обнуление основного массива.
     **/
    void clear();

    /**
     * @return - имеет ли итератор следующий шаг
     * false если все значения массива единицы длины n
     **/
    bool has_next();

    /**
     *  Шаг итерации массива array
     *  После достижения максимального значения обнуляется
     **/
    void operator++();
};

/**
 * Жадный алгоитм
 * Класс поиска минимального множества образующего покрытие
 *  в заданых множествах
 **/
template <class T>
class greedy_algo {
private:
    T *a;

    /**
     * Массив хранит количество единиц в каждом слове
     **/
    short * sum;

    /**
     * Массивы хранят номера слов в порядке убывания количества бит
     **/
    short * srt[2];

    /**
     * Длина слова
     **/
    int n;

    /**
     * к-во слов
     **/
    int k;

    /**
     * флаг текущего варианта srtc++ header file template
     **/
    bool b;

    /**
     * Максимально возможное число.
     * 1  - 1
     * 3  - 11
     * 7  - 111
     * 15 - 1111
     * и т. д.
     **/
    T m;

public:

    /**
     * @param a - основной массив
     * @param n - длина слова
     * @param k - количество слов
     **/
    greedy_algo(T *a_, int n_, int k_);

    /**
     * Деструктор
     **/
    ~greedy_algo();
    
    /**
     * Обнуление полей класса 
     * нужно выполнять перед обработкой следуещего числа
     **/
    void clear();

    /**
     * Сорировка слов по количеству единиц
     * индексирут основной массив a 
     * по результату работы 
     * заполняет массивы sum, srt[0], srt[1] и флаг b
     * 
     * текущее значении b укаывает на массив srt хранящий номера 
     * массива T *а в нисходящем порядке
     **/
    void sort();

    /**
     * Рекурсивная функция поиска минимального множества
     * @param s - маска числа.
     * к премеру, запуск функции начинается
     * с 0000 далее при обходе 0110, 0111 и т д.
     * 
     * @param r - номер слова
     * поиска идет слева направа от 0 до n
     * 
     * @return  
     * 0 - если не содержит полного покрытия
     * > 0 - если содержит 
     * unsigned int - маска которого соответствует найденому
     * минимальному покрытию
     * к примеру, 000101
     * значит в массиве a слова a[0] a[2] образуют 
     * минимальное покрытие
     * для результата 011100 - соответственно a[2] a[3] a[4]
     **/
    unsigned long recur(T s, int r);

    /**
     * основная функция класса для внешнего вызова
     * @return результат поиска 
     * в формате результатов recur() 
     **/
    unsigned long invoke();
};

#include "setcover.tpp"

#endif	/* SETCOVER_H */